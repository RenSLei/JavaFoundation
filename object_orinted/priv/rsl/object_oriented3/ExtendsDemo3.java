package priv.rsl.object_oriented3;
/*
子父类出现后，类成员的特点：

类中成员：
1、变量
2、函数
3、构造函数

3、子父类中的构造函数

在对子类对象进行初始化时，父类的构造函数也会运行，那是因为子类的构造函数默认第一行有一条隐式的语句super();
super();会访问父类中空参数的构造函数，而且每一个子类中所有的构造函数默认第一行都有一条隐式的super();

为什么子类一定要访问父类的构造函数？
答：因为父类中的数据子类可以直接获取；所以子对象在建立时，需要先查看父类是如何对这些数据进行初始化的。
如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

注意：super语句一定定义在子类构造函数的第一行。


子类的实例化过程：

结论：子类的所有的构造函数默认都会访问父类中空参数的构造函数。
因为子类每一个构造函数的第一行都有一句隐式super();

当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问父类中的构造函数。
当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数。
子类中至少会有一个构造函数会访问父类中的构造函数。


*/

class Fu3
{
	int num;

	Fu3(int x)
	{
		num=60;
		System.out.println("fu run"+x);
	}
}

class Zi3 extends Fu3/*Zi继承Fu，Zi中有Fu的全部内容*/
{
	Zi3()
	{
		//super();默认有一条隐式的语句，调用父类空参数构造函数；当父类中没有空参数的构造函数怎么办？
		super(4);//此时就必须手动添加一个调用与之对应的调用语句,否则编译失败；
		System.out.println("num="+num);//若不访问父类的构造函数，则输出的num为0
	}
	Zi3(int x)
	{
		//super();
		super(8);//同上
		System.out.println("x="+x);
	}
}

class  ExtendsDemo3
{
	public static void main(String[] args) 
	{
		new Zi3();//子类中一建立对象z，则对对象初始化的构造函数先执行super();即打印fu run接着打印zi run
		new Zi3(5);//子类中一建立对象z1，则对对象初始化的构造函数先执行super();即打印fu run接着打印x=5
	}
}

